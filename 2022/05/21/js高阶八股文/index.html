<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"muleandhorse.icu","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. this 的绑定规则 默认绑定：独立函数调用，函数没有被绑定到某个对象上进行调用—指向window  隐式绑定：通过某个对象发起的函数调用，在调用对象内部有一个对函数的引用。—指向调用的上一级对象,留意箭头函数  显式绑定：明确 this 指向的对象，第一个参数相同并要求传入一个对象。  apply&#x2F;call—call传入的是单个变量,apply传入的是一个数组 bind—不会立即">
<meta property="og:type" content="article">
<meta property="og:title" content="JS高阶的一些八股文">
<meta property="og:url" content="http://muleandhorse.icu/2022/05/21/js%E9%AB%98%E9%98%B6%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="Mule and Horse">
<meta property="og:description" content="1. this 的绑定规则 默认绑定：独立函数调用，函数没有被绑定到某个对象上进行调用—指向window  隐式绑定：通过某个对象发起的函数调用，在调用对象内部有一个对函数的引用。—指向调用的上一级对象,留意箭头函数  显式绑定：明确 this 指向的对象，第一个参数相同并要求传入一个对象。  apply&#x2F;call—call传入的是单个变量,apply传入的是一个数组 bind—不会立即">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-21T06:06:09.000Z">
<meta property="article:modified_time" content="2023-07-22T13:14:06.978Z">
<meta property="article:author" content="RickyD">
<meta property="article:tag" content="前端开发">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://muleandhorse.icu/2022/05/21/js%E9%AB%98%E9%98%B6%E5%85%AB%E8%82%A1%E6%96%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JS高阶的一些八股文 | Mule and Horse</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mule and Horse</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个工地仔的救赎之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">67</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://muleandhorse.icu/2022/05/21/js%E9%AB%98%E9%98%B6%E5%85%AB%E8%82%A1%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="RickyD">
      <meta itemprop="description" content="如果站长加班加似了，这个网站就是他留给世界最后的遗产">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mule and Horse">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JS高阶的一些八股文
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-21 14:06:09" itemprop="dateCreated datePublished" datetime="2022-05-21T14:06:09+08:00">2022-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-22 21:14:06" itemprop="dateModified" datetime="2023-07-22T21:14:06+08:00">2023-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>40 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-this-的绑定规则"><a href="#1-this-的绑定规则" class="headerlink" title="1. this 的绑定规则"></a>1. this 的绑定规则</h2><ul>
<li><p>默认绑定：独立函数调用，函数没有被绑定到某个对象上进行调用—指向window</p>
</li>
<li><p>隐式绑定：通过某个对象发起的函数调用，在调用对象内部有一个对函数的引用。—指向调用的上一级对象,留意箭头函数</p>
</li>
<li><p>显式绑定：明确 this 指向的对象，第一个参数相同并要求传入一个对象。</p>
<ul>
<li>apply&#x2F;call—call传入的是单个变量,apply传入的是一个数组</li>
<li>bind—不会立即执行调用bind的函数</li>
</ul>
</li>
<li><p>new 绑定：</p>
<ul>
<li>创建一个全新对象</li>
<li>新对象被执行 prototype 链接</li>
<li>新对象绑定到函数调用的 this</li>
<li>如果函数没有返回其他对象，表达式会返回这个对象</li>
</ul>
</li>
</ul>
<h2 id="2-说出-apply、call、bind-函数的用法和区别"><a href="#2-说出-apply、call、bind-函数的用法和区别" class="headerlink" title="2. 说出 apply、call、bind 函数的用法和区别"></a>2. 说出 apply、call、bind 函数的用法和区别</h2><p> 用法：</p>
<ul>
<li><p>apply</p>
<p>第一个参数: 绑定 this</p>
<p>第二个参数: 传入额外的实参, 以数组的形式</p>
</li>
<li><p>call</p>
<p>第一个参数: 绑定 this</p>
<p>参数列表: 后续的参数以多参数的形式传递, 会作为实参</p>
</li>
<li><p>bind(不希望 obj 对象身上有函数)</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj)</span><br><span class="line">​    <span class="title function_">bar</span>() <span class="comment">// this -&gt; obj</span></span><br></pre></td></tr></table></figure>

<p>  区别：</p>
<ul>
<li><p>call、apply 和 bind 都可以改变函数的 this 指向</p>
</li>
<li><p>call、apply 和 bind 第一个参数的是 this 要指向的对象</p>
</li>
<li><p>call、apply 和 bind 都可以后续为函数传参，apply 是将参数并成一个数组，call 和 bind 是将参数依次列出</p>
</li>
<li><p>call、apply 都是直接调用，bind 生成的 this 指向改变函数需要手动调用。</p>
</li>
</ul>
<h2 id="3-说出箭头函数的各种用法和简写"><a href="#3-说出箭头函数的各种用法和简写" class="headerlink" title="3. 说出箭头函数的各种用法和简写"></a>3. 说出箭头函数的各种用法和简写</h2><ul>
<li><p>基本写法</p>
<ul>
<li><p>()：函数的参数</p>
</li>
<li><p>{}:函数的执行体</p>
</li>
<li><pre><code class="js">var foo3 = (name, age) =&gt; &#123;
  console.log(&#39;箭头函数的函数体&#39;);
  console.log(name, age);
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 优化写法</span><br><span class="line"></span><br><span class="line">  - 只有一个参数时, 可以省略()</span><br><span class="line"></span><br><span class="line">    ```js</span><br><span class="line">    names.forEach((item) =&gt; &#123;</span><br><span class="line">      console.log(item);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>只有一行代码时, 可以省略{}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item));</span><br></pre></td></tr></table></figure>
</li>
<li><p>只要一行代码时, 表达式的返回值会作为箭头函数默认返回值, 所以可以省略 return</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newNums = nums.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> newNums = nums.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果箭头函数默认返回的是对象, 在省略{}的时候, 对象必须使用()包裹 () &#x3D;&gt; ({name: “alex”})</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">arrFn</span> = (<span class="params"></span>) =&gt; [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">arrFn</span> = (<span class="params"></span>) =&gt; &#123;&#125;; <span class="comment">// 注意: 这里是&#123;&#125;执行体</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">arrFn</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">name</span>: <span class="string">&#x27;alex&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrFn</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="4-说出浏览器输入一个-URL-到页面显示的过程"><a href="#4-说出浏览器输入一个-URL-到页面显示的过程" class="headerlink" title="4. 说出浏览器输入一个 URL 到页面显示的过程"></a>4. 说出浏览器输入一个 URL 到页面显示的过程</h2><ul>
<li>首先通过 DNS 服务器进行域名解析</li>
<li>解析出对应的 IP 地址 然后从 ip 地址对应的主机发送 http 请求 获取对应的静态资源(此时会有TCP的三次握手,目的是确认服务端和客户端的发送和接受能力是否都是正常的)<ol>
<li>客户端向服务端发送请求</li>
<li>等待服务端的确认,并恢复一个指令</li>
<li>客户端再次确认,服务器就会返回数据</li>
</ol>
</li>
<li>默认情况服务器会返回 index.html 文件,拿到文件之后会有(四次挥手,与服务器断开tcp链接)</li>
<li>然后浏览器内核开始解析 HTML</li>
<li>首先 会解析对应的 html 生成 DOM Tree</li>
<li>解析过程中 如果遇到 css 的 link 标签 则会下载对应的 css 文件<ul>
<li>下载 css 文件和生成 DOM 树是同时进行</li>
</ul>
</li>
<li>下载完对应的 css 文件后会进行 css 解析 生成 CSSOM( CSS object model)</li>
<li>当 DOM Tree 和 CSSTree 都解析完成之后 会进行合并用来生成 Render Tree(渲染树)</li>
<li>初步生成的渲染树会显示节点以及部分样式 但是并不表示每个节点的尺寸 位置信息 于是进行 Layout(布局)来生成渲染树中节点的宽度 高度位置信息</li>
<li>经过 Layout 之后 浏览器内核将布局时的每个 frame 转屏幕上的每个像素点 将每个节点绘制到屏幕上</li>
</ul>
<p><code>注意: 第一次确定节点的大小位置 称之为布局(Layout) 之后对节点大小位置改变后的重新计算称之为回流</code></p>
<p>引起回流的情况:</p>
<ul>
<li>DOM 结构发生改变(节点的增删)</li>
<li>修改了节点的布局(宽度 高度 字体大小等)</li>
<li>修改窗口的尺寸</li>
<li>调用 getComputedStyle 获取位置信息</li>
</ul>
<p><code>第一次绘制节点 渲染到页面上称之为绘制(paint) 之后重新绘制 称之为重绘</code></p>
<p>引起重绘情况:</p>
<ul>
<li>修改背景色颜色 等</li>
</ul>
<p><code>回流一定会引起重绘 所以回流非常消耗性能</code></p>
<p>如何避免回流</p>
<ul>
<li>尽量一次性的修改样式<ul>
<li>通过添加 classList</li>
</ul>
</li>
<li>避免频繁的操作 DOM</li>
<li>避免通过 getComputedStyle 获取尺寸位置信息等</li>
<li>对于某些元素使用 position:absolute&#x2F;fixed<ul>
<li>开销较小 不会对其他元素造成影响</li>
</ul>
</li>
</ul>
<p>第二次访问这个url,将域名解析的ip保存在本地,浏览器会读取缓存,</p>
<h2 id="5-说说-async-和-defer-的使用以及区别"><a href="#5-说说-async-和-defer-的使用以及区别" class="headerlink" title="5. 说说 async 和 defer 的使用以及区别"></a>5. 说说 async 和 defer 的使用以及区别</h2><p>浏览器在解析构建 DOM 树的过程中 如果遇到 script 元素会停止构建 DOM 树 先下载 JavaScript 代码 执行对应的脚本</p>
<p>但是某些 JavaScript 代码中可能存在对某个节点的操作 如果等待 DOM 树构建完成 之后在进行对应的操作 则会造成大量的回流和重绘</p>
<p>同时在如果 JavaScript 代码过多 则浏览器处理的时间会过长 则会造成页面的阻塞</p>
<p>为了解决这个问题 <code>script标签</code>出现了两个属性 async defer</p>
<p>defer</p>
<ul>
<li>脚本的下载会与 DOM 树的构建同时进行</li>
<li>如果脚本提前下载好了 则会等到 DOM 树构建完成之后 在 DOMContentLoaded 事件之前执行 defer 中的代码</li>
<li>同时多个 defer 属性的 script 标签 则会按照顺序执行</li>
<li>推荐放到 head 标签中 可以早解析</li>
<li>对于 script 默认的内容 会忽略</li>
</ul>
<p>async</p>
<ul>
<li>脚本的下载会与 DOM 树的构建同时进行</li>
<li>让一个脚本完全独立 脚本的解析 运行于 DOM 的构建无关</li>
<li>多个 async 属性的脚本不保证运行顺序</li>
<li>通常用于独立的脚本 对于其他脚本 DOM 没有依赖</li>
</ul>
<h2 id="6-写出-v8-引擎执行代码的大致流程"><a href="#6-写出-v8-引擎执行代码的大致流程" class="headerlink" title="6. 写出 v8 引擎执行代码的大致流程"></a>6. 写出 v8 引擎执行代码的大致流程</h2><ul>
<li>Parse 模块 将 JavaScript 代码转成 AST Tree</li>
<li>Ignition :解释器 将 ASTTree 转换为字节码(byte Code)<ul>
<li>同时收集 TurboFan 优化需要的信息</li>
</ul>
</li>
<li>TurboFan :编译器 将字节码编译为 CPU 可以直接执行的机器码(machine code)<ul>
<li>如果某一个函数被多次调用 则会被标记为热点函数 会经过 TurBoFan 转换的优化的机器码 让 CPU 执行 提高代码性能</li>
<li>如果后续执行代码过程中 改函数调用时的参数类型发生了改变 则会逆向的转成字节码 让 CPU 执行</li>
</ul>
</li>
</ul>
<p>执行流程:</p>
<ul>
<li><p>首先会编译 JavaScript 编译过程分为三步</p>
</li>
<li><p>1 词法分析(scanner)</p>
<ul>
<li>会将对应的每一行的代码的字节流分解成有意义的代码块 代码块被称为词法单元(token 进行记号化)</li>
</ul>
</li>
<li><p>2 语法分析(parser)</p>
<ul>
<li>将对应的 tokens 分析成一个元素逐级嵌套的树 这个树称之为 抽象语法树(Abstract Syntax Tree AST)</li>
<li>这里也有对应的 pre-parser</li>
</ul>
</li>
<li><p>3 将 AST 通过 Ignition 解释器转换成对应的字节码(ByteCode) 交给 CPU 执行 同时收集信息</p>
<ul>
<li>将可优化的信息 通过 TurBoFan 编译器 编译成更好使用的机器码交给 CPU 执行</li>
<li>如果后续代码的参数类型发生改变 则会逆优化(Deoptimization)为字节码</li>
</ul>
</li>
</ul>
<h2 id="7-说一下-JavaScript-的代码的执行流程"><a href="#7-说一下-JavaScript-的代码的执行流程" class="headerlink" title="7. 说一下 JavaScript 的代码的执行流程"></a>7. 说一下 JavaScript 的代码的执行流程</h2><ul>
<li>首先在执行前会现在堆内存中开辟一块空间(GO) 存放一些初始的值 如 Number String 等等</li>
<li>还有代码中定义的一些变量 函数(在 parser 转成 AST 树的过程中存放在 GO 中的 )并没有赋值</li>
<li>同时在执行代码时在执行上下文栈(ECS)中存放一个全局执行上下文(GEC) 用于执行代码<ul>
<li>GO 中对应的函数 也会在堆内存中开辟出空间 为 Function Object 初始一些数据(name length scope chain 等)</li>
</ul>
</li>
<li>开始执行代码</li>
<li>每个 EC 中有着三个重要的内容(VO scope chain 以及 this)</li>
<li>VO 指向对应的作用域(全局作用域(GO) 函数作用域(AO))</li>
</ul>
<h2 id="8-说说你对-GO-x2F-AO-x2F-VO-的理解以及作用域和作用域链的理解"><a href="#8-说说你对-GO-x2F-AO-x2F-VO-的理解以及作用域和作用域链的理解" class="headerlink" title="8. 说说你对 GO&#x2F;AO&#x2F;VO 的理解以及作用域和作用域链的理解"></a>8. 说说你对 GO&#x2F;AO&#x2F;VO 的理解以及作用域和作用域链的理解</h2><p>GO</p>
<ul>
<li>Global Object JS 代码在执行前会现在堆内存中创建一个全局对象(GO)</li>
<li>用于存放一些定义好的变量方法等包含 Date Array String Number setTimeout 等</li>
<li>同时有一个 window 属性指向自己</li>
<li>同时在语法分析转成 AST 的过程中也会将一些变量 函数 存放在 GO 中 只是变量的初始值为 undefined</li>
</ul>
<p>AO</p>
<ul>
<li>函数在执行前会先在堆内存中创建一个 AO(Activation Object)对象 里面存放这 arguments 对应函数的形参 以及在函数中定义的变量 初始值为 undefined</li>
</ul>
<p>VO</p>
<ul>
<li>Variable Object 在执行函数时 会在执行上下文栈(ECS)中进入一个函数执行上下文(FEC)其中有三个核心 核心之一是 VO 指向的是该函数在内存中解析时创建的 AO 而在全局执行上下文中指向的是 GO</li>
</ul>
<p>作用域,作用域链</p>
<ul>
<li>当进入到一个执行上下文时 执行上下文会关联一个作用域链</li>
<li>通常作用域链在解析时就被确定 因此 作用域链域函数的定义位置有关 而与它的调用位置无关</li>
</ul>
<h2 id="9-说说-V8-引擎的内存管理以及垃圾回收器"><a href="#9-说说-V8-引擎的内存管理以及垃圾回收器" class="headerlink" title="9. 说说 V8 引擎的内存管理以及垃圾回收器"></a>9. 说说 V8 引擎的内存管理以及垃圾回收器</h2><p>内存管理</p>
<ul>
<li>JavaScript 的内存管理是自动的</li>
<li>关于原始数据类型 直接在栈内存中分配</li>
<li>关于复杂数据类型 在堆内存中分配</li>
</ul>
<p>垃圾回收(GC)</p>
<ul>
<li>因为内存大小是有限的 所以在内存不需要的时候 需要进行释放 用于腾出空间</li>
<li>GC 对于内存管理有着对应的算法</li>
<li>常见的算法<ul>
<li>引用计数(Reference Count)<ul>
<li>当一个对象有引用指向它时 对应的引用计数+1</li>
<li>当没有对象指向它时 则为 0 此时进行回收</li>
<li>但是有一个严重的问题 - 会产生循环引用</li>
</ul>
</li>
<li>标记清除(Mark-Sweep)<ul>
<li>核心思路: 可达性</li>
<li>有一个根对象 从该对象出发 开始引用到所用到的对象 对于根对象没有引用到的对象 认为是不可用的对象</li>
<li>对于不可用的对象 则进行回收</li>
<li>该算法有效的解决了循环引用的问题</li>
<li>目前 V8 引擎采用的就是该算法</li>
</ul>
</li>
</ul>
</li>
<li>V8 引擎为了优化 在采用标记清除的过程中也引用了其他的算法<ul>
<li>标记整理<ul>
<li>和标记清除相似 不同的是回收时 会将保留下来的存储对象整合到连续的内存空间 避免内存碎片化</li>
</ul>
</li>
<li>分代收集(Generational Collection)<ul>
<li>将内存中的对象分为两组 新的空间 旧的空间</li>
<li>对于长期存活的对象 会将该对象从新空间移到旧空间中 同时 GC 检查次数减少</li>
<li>将新空间分为 from 和 to 对象的 GC 查找之后从 from 移动到 to 空间中 然后 to 变为 from from 变为 to 循环几次 对于依然存在的对象 移动到旧空间中</li>
</ul>
</li>
<li>增量收集(Increment Collection)<ul>
<li>如果存在许多对象 则 GC 试图一次性遍历所有的对象 可能会对性能造成一定的影响</li>
<li>所以引擎试图将垃圾收集工作分成几部分 然后这几部分逐一处理 这样会造成微小的延迟 而不是很大的延迟</li>
</ul>
</li>
<li>闲时收集(IdIe-time Collection)<ul>
<li>GC 只会在 CPU 空闲的时候运行 减少可能对代码执行造成的影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="10-你是如何理解闭包的-闭包到底是什么"><a href="#10-你是如何理解闭包的-闭包到底是什么" class="headerlink" title="10. 你是如何理解闭包的,闭包到底是什么?"></a>10. 你是如何理解闭包的,闭包到底是什么?</h2><p>广义上讲 JavaScript 的函数都是闭包</p>
<p>狭义上将 JavaScript 中的函数如果访问了外层作用域中的变量 则称为闭包</p>
<p>实现上是一个函数与包含它的作用的引用绑定在了一起的组合</p>
<h2 id="11-闭包为什么会产生内存泄露以及如何解决"><a href="#11-闭包为什么会产生内存泄露以及如何解决" class="headerlink" title="11. 闭包为什么会产生内存泄露以及如何解决"></a>11. 闭包为什么会产生内存泄露以及如何解决</h2><ul>
<li><p>闭包使得原本该销毁的作用域由于内部函数的引用没有销毁 始终存在在堆内存中 因此产生了内存泄露</p>
</li>
<li><p>解决</p>
<ul>
<li>将保存着上层作用域引用的函数在使用完之后置为 null 将它的引用销毁在 GC 的下一次检查中 对应的内存就会被销毁</li>
</ul>
</li>
</ul>
<h2 id="12-理解纯函数以及编写自己的纯函数"><a href="#12-理解纯函数以及编写自己的纯函数" class="headerlink" title="12. 理解纯函数以及编写自己的纯函数"></a>12. 理解纯函数以及编写自己的纯函数</h2><p>纯函数：纯函数一般具有以下的特点：</p>
<ul>
<li>确定的输入一定会有确定的输出（外部环境的任何变化不会影响函数内部的操作产生的结果）</li>
<li>纯函数的执行不会产生副作用。（函数内部的操作也不会对函数外部产生任何影响）</li>
</ul>
<p>编写纯函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般的数学方法可以写成纯函数,例如相加</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">perValue, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> preValue + item;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-理解函数柯里化以及说出柯里化的作用"><a href="#13-理解函数柯里化以及说出柯里化的作用" class="headerlink" title="13. 理解函数柯里化以及说出柯里化的作用"></a>13. 理解函数柯里化以及说出柯里化的作用</h2><p>函数的柯里化：将传入多个参数的函数转变成传入单个参数并且返回一个函数用于接收剩余的参数的函数。每一层函数都接收一个参数并对参数进行处理。</p>
<p>柯里化的作用：</p>
<ul>
<li>单一职责：每一个函数只用处理传入的单个参数，每个函数的职责单一而且确定</li>
<li>参数复用：可以拿到每一层函数执行的返回值作为一个新的函数，复用已经传入过的参数。</li>
</ul>
<h2 id="14-理解组合函数以及组合函数的作用"><a href="#14-理解组合函数以及组合函数的作用" class="headerlink" title="14. 理解组合函数以及组合函数的作用"></a>14. 理解组合函数以及组合函数的作用</h2><p>组合函数：组合函数是将多个函数组合到一起，进行依次调用的函数使用模式。</p>
<p>组合函数的作用：</p>
<ul>
<li>减少重复代码的编写，提高代码的复用性，便于开发。</li>
<li>可以对任意个函数进行组合，返回新的具有多个被组合函数功能的新函数</li>
</ul>
<h2 id="15-说说你对严格模式的理解"><a href="#15-说说你对严格模式的理解" class="headerlink" title="15. 说说你对严格模式的理解"></a>15. 说说你对严格模式的理解</h2><p>严格模式是一种 JavaScript 的限制模式，因为种种历史原因，JavaScript 语言在非严格模式下是比较松散的。在 JavaScript 不断优化和加入新特性的过程中，为了兼容早期的 JavaScript，一些错误和不规范的写法也被保留了下来。这些错误也不会被抛出。在开启了严格模式后，js 引擎会以一种更严格的规范执行 JavaScript 代码，一些不规范的写法和错误也会直接抛出。</p>
<p>开启严格模式的方法：</p>
<ul>
<li>对文件开启：在文件的开头写上”use strict”</li>
<li>对函数开启：在函数的开头写上”use strict”</li>
</ul>
<p>严格模式下的语法限制：</p>
<ul>
<li>不允许意外创建全局变量（不写 var、let、const 这种声明变量的关键字）</li>
<li>会对静默失败的赋值操作抛出异常</li>
<li>试图删除不可删除的属性</li>
<li>不允许函数参数有相同的名称</li>
<li>不允许只有 0 开头的八进制语法</li>
<li>不允许使用 with</li>
<li>无法获取 eval 中定义的变量</li>
<li>this 绑定不会默认转成对象</li>
</ul>
<h2 id="16-什么是原型、原型链？"><a href="#16-什么是原型、原型链？" class="headerlink" title="16. 什么是原型、原型链？"></a>16. 什么是原型、原型链？</h2><p>原型：在 JavaScript 中，每一个对象都会有一个属性 <code>__proto__([[prototype]])</code>，这个属性就是对象的原型，这个属性的值也是一个对象，是原对象的原型对象。访问对象中属性时，会先在对象自身进行查找，如果没有找到，那么会去对象的原型对象上查找。</p>
<p>原型链：每个对象都有自己的原型对象，原型对象也有自己的原型对象。在访问对象的属性时，会沿着对象自身&#x3D;&gt;自身的原型对象&#x3D;&gt;原型对象的原型对象……这样的链条一路查找上去，这条链式结构就叫做原型链。原型链的尽头是 Object 的原型对象的<code>__proto__([[prototype]])</code>属性，值为 null。</p>
<h2 id="17-ES5-继承的各个方案以及优缺点"><a href="#17-ES5-继承的各个方案以及优缺点" class="headerlink" title="17. ES5 继承的各个方案以及优缺点"></a>17. ES5 继承的各个方案以及优缺点</h2><p>方案一：原型继承-子类的原型指向父类的实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>优点：<br>父类的构造函数体内 和 原型上的内容都能继承下来<br>缺点：<br>继承下来的属性不在自己身上，子类实例的属性分开来写，s 的属性自己身上有一部分，原型上有一部分</p>
<hr>
<p>方案二：call 继承-利用 call 调用父类构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">gender, ...args</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：<br>可以把继承来的属性 直接出现在子类的实例上<br>一个实例使用的属性可以在一个位置传递参数了<br>缺点：<br>只能继承 构造函数体内书写的内容 构造函数的 原型上的 不能继承</p>
<hr>
<p>方案三：组合继承-结合上述两种方案</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">arg1, arg2</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, arg1, arg2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>缺点：父类构造函数会被调用两次，并且子类的实例对象总是有两份相同的属性，一份在自身，一份在其原型对象上</p>
<h2 id="18-编写-ES6-的类并且实现继承"><a href="#18-编写-ES6-的类并且实现继承" class="headerlink" title="18. 编写 ES6 的类并且实现继承"></a>18. 编写 ES6 的类并且实现继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age, address</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">address</span> = address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;在跑步&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">createPerson</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// return new Person(Math.floor(Math.random() * 100));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">this</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age, height, address</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, age, address);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写running方法</span></span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是student里的&#x27;</span>);</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">running</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">createStudent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// return new Person(Math.floor(Math.random() * 100));</span></span><br><span class="line">    <span class="comment">// console.log(&quot;我是student里的静态方法&quot;);</span></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">createPerson</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">23</span>, <span class="number">190</span>, <span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line">stu.<span class="title function_">running</span>();</span><br><span class="line"><span class="keyword">var</span> createPerson1 = <span class="title class_">Student</span>.<span class="title function_">createPerson</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(createPerson1);</span><br></pre></td></tr></table></figure>

<h2 id="19-说说你对面向对象多态的理解"><a href="#19-说说你对面向对象多态的理解" class="headerlink" title="19. 说说你对面向对象多态的理解"></a>19. 说说你对面向对象多态的理解</h2><p>不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现</p>
<h2 id="20-整理-ES6-ES11-新增知识点"><a href="#20-整理-ES6-ES11-新增知识点" class="headerlink" title="20. 整理 ES6~ES11 新增知识点"></a>20. 整理 ES6~ES11 新增知识点</h2><p>ES6 :</p>
<ul>
<li>使用 class 用来定义类<ul>
<li>constructor 构造器</li>
<li>extends 实现继承</li>
<li>super 关键字代表继承的父类</li>
</ul>
</li>
<li>对象字面量的增强<ul>
<li>属性的简写</li>
<li>方法的简写</li>
<li>计算属性名</li>
</ul>
</li>
<li>解构</li>
<li>let&#x2F;const 的使用<ul>
<li>不能重复声明变量</li>
<li>不存在作用域提升</li>
<li>存在暂时性死区</li>
<li>不添加 window</li>
<li>存在块级作用域</li>
</ul>
</li>
<li>字符串模板<ul>
<li>在模板字符串中，我们可以通过 ${expression} 来嵌入动态的内容</li>
<li>标签模板字符串</li>
</ul>
</li>
<li>函数的默认参数</li>
<li>函数的剩余参数</li>
<li>箭头函数<ul>
<li>没有显式原型 prototype</li>
<li>不绑定 this、arguments、super 参数</li>
</ul>
</li>
<li>展开语法<ul>
<li>在函数调用时使用；</li>
<li>在数组构造时使用；</li>
<li>展开运算符其实是一种浅拷贝</li>
<li>在构建对象字面量时，也可以使用展开运算符，这个是在 ES2018（ES9）中添加的新特性；</li>
</ul>
</li>
<li>规范了二进制和八进制的写法</li>
<li>新增 Symbol</li>
<li>Set、WeakSet、Map、WeakMap</li>
</ul>
<p>ES7 :</p>
<ul>
<li>Array Includes<ul>
<li>通过 includes 来判断一个数组中是否包含一个指定的元素，根据情况，包含返回 true，否则返回 false。</li>
</ul>
</li>
<li>指数 exponentiation 运算符<ul>
<li>**,对数字来计算乘方。</li>
</ul>
</li>
</ul>
<p>ES8 :</p>
<ul>
<li>Object values<ul>
<li>通过 Object.values 来获取所有的 value 值</li>
</ul>
</li>
<li>Object entries<ul>
<li>通过 Object.entries 可以获取到一个数组，数组中会存放可枚举属性的键值对数组</li>
</ul>
</li>
<li>String Padding<ul>
<li>padStart 和 padEnd 方法，分别对字符串的首尾进行填充的。</li>
</ul>
</li>
<li>Trailing Commas<ul>
<li>允许在函数定义和调用时多加一个逗号：</li>
</ul>
</li>
<li>Object.getOwnPropertyDescriptors</li>
</ul>
<p>ES9 :</p>
<ul>
<li>构建对象字面量时，可以使用展开运算符</li>
</ul>
<p>ES10 :</p>
<ul>
<li>flat<ul>
<li>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</li>
</ul>
</li>
<li>flatMap<ul>
<li>flatMap 是先进行 map 操作，再做 flat 的操作</li>
<li>flatMap 中的 flat 相当于深度为 1</li>
</ul>
</li>
<li>Object fromEntries<ul>
<li>Object.formEntries 将 entries 转换成一个对象</li>
</ul>
</li>
<li>trimStart trimEnd<ul>
<li>去除字符串前面或者后面的空格</li>
</ul>
</li>
</ul>
<p>ES11 :</p>
<ul>
<li>BigInt<ul>
<li>BigInt，用于表示大的整数(超过最大安全整数)</li>
<li>BitInt 的表示方法是在数值的后面加上 n</li>
</ul>
</li>
<li>空值合并操作符<ul>
<li>??当前面的值为 null 或者 undefined 时,显示??后面的值</li>
</ul>
</li>
<li>Optional Chaining<ul>
<li>可选链?.</li>
<li>当?.前面的值为空时返回 undefined</li>
</ul>
</li>
<li>Global This<ul>
<li>JavaScript 环境的全局对象</li>
</ul>
</li>
<li>for..in 标准化<ul>
<li>for…in 遍历对象时遍历的是 key</li>
</ul>
</li>
</ul>
<h2 id="21-说说-Symbol-的用法和作用"><a href="#21-说说-Symbol-的用法和作用" class="headerlink" title="21. 说说 Symbol 的用法和作用"></a>21. 说说 Symbol 的用法和作用</h2><p>用法</p>
<ul>
<li>Symbol 值是通过 Symbol 函数来生成的</li>
<li>Symbol()表示生成一个独一无二的值</li>
<li>我们也可以在创建 Symbol 值的时候,在()里面传入一个 description,描述当前的 Symbol</li>
<li>获取 Symbol,使用 Object.getOwnPropertySymbols()获取当前对象的 Symbol,结果为一个数组</li>
</ul>
<p>作用</p>
<ul>
<li>用于对象的属性名,表示一个唯一的属性名</li>
</ul>
<p>相同值的 Symbol:</p>
<ul>
<li>使用 Symbol.for()生成,当 key 一样的时候,生成表示相同的 Symbol</li>
<li>Symbol.keyFor(Symbol.for())获取对应的 key</li>
</ul>
<h2 id="22-说说你对-Set、WeakSet、Map、WeakMap-的了解"><a href="#22-说说你对-Set、WeakSet、Map、WeakMap-的了解" class="headerlink" title="22. 说说你对 Set、WeakSet、Map、WeakMap 的了解"></a>22. 说说你对 Set、WeakSet、Map、WeakMap 的了解</h2><p>Set:</p>
<ul>
<li>用来存储数据,类似于数组,</li>
<li>与数组的区别是元素不能重复,</li>
<li>可以使用 forEach 方法和使用 for…of…遍历</li>
<li>常见属性和方法<ul>
<li>size：返回 Set 中元素的个数</li>
<li>add(value)：添加某个元素，返回 Set 对象本身</li>
<li>delete(value)：从 set 中删除和这个值相等的元素，返回 boolean 类型</li>
<li>has(value)：判断 set 中是否存在某个元素，返回 boolean 类型</li>
<li>clear()：清空 set 中所有的元素</li>
<li>forEach(callback, [, thisArg])：通过 forEach 遍历 set</li>
</ul>
</li>
</ul>
<p>WeakSet:</p>
<ul>
<li>只能存储对象类型,不能存放基本数据类型,</li>
<li>对对象的引用是一个弱引用,如果没有其他对对象的引用,那么相应对象会被 GC 进行清除,</li>
<li>不能遍历</li>
<li>常见的方法<ul>
<li>add(value)：添加某个元素，返回 WeakSet 对象本身</li>
<li>delete(value)：从 WeakSet 中删除和这个值相等的元素，返回 boolean 类型</li>
<li>has(value)：判断 WeakSet 中是否存在某个元素，返回 boolean 类型</li>
</ul>
</li>
</ul>
<p>Map:</p>
<ul>
<li>用于存储映射关系,存储的为键值对,</li>
<li>每个键值对为一个数组,</li>
<li>与对象的区别是存储的 key 可以为一个对象</li>
<li>可以使用 forEach 方法和使用 for…of…遍历</li>
<li>常见属性和方法<ul>
<li>size：返回 Set 中元素的个数</li>
<li>set(key, value)：在 Map 中添加 key、value，并且返回整个 Map 对象</li>
<li>get(key)：根据 key 获取 Map 中的 value</li>
<li>has(key)：判断是否包括某一个 key，返回 Boolean 类型</li>
<li>delete(key)：根据 key 删除一个键值对，返回 Boolean 类型</li>
<li>clear()：清空所有的元素</li>
<li>forEach(callback, [, thisArg])：通过 forEach 遍历 Map</li>
</ul>
</li>
</ul>
<p>WeakMap:</p>
<ul>
<li>存储的 key 只能为对象,不允许是其他类型</li>
<li>对对象的引用是一个弱引用,如果没有其他对对象的引用,那么相应对象会被 GC 进行清除,</li>
<li>不能进行遍历</li>
<li>常见的方法<ul>
<li>set(key, value)：在 Map 中添加 key、value，并且返回整个 Map 对象</li>
<li>get(key)：根据 key 获取 Map 中的 value</li>
<li>has(key)：判断是否包括某一个 key，返回 Boolean 类型</li>
<li>delete(key)：根据 key 删除一个键值对，返回 Boolean 类型</li>
</ul>
</li>
</ul>
<h2 id="23-说一下引用赋值-浅拷贝-深拷内存情况"><a href="#23-说一下引用赋值-浅拷贝-深拷内存情况" class="headerlink" title="23. 说一下引用赋值-浅拷贝-深拷内存情况"></a>23. 说一下引用赋值-浅拷贝-深拷内存情况</h2><p>引用赋值: 将一个变量中存储的对对象的引用地址赋值给另一个变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = obj;</span><br></pre></td></tr></table></figure>

<p>浅拷贝:</p>
<ul>
<li>使用…运算符展开一个对象时是一种浅拷贝,</li>
<li>只是将对像内的内容进行简单的复制,</li>
<li>如果对象中存储的内容为另一个对象时,并不是将另一个对象进行复制,</li>
<li>而是将外面对象内存储的对里面对象的引用进行复制</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xfj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;alex&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; ...obj &#125;;</span><br></pre></td></tr></table></figure>

<p>深拷贝:</p>
<ul>
<li>完完全全的创建一个和原来的对象有相同结构的新的对象,</li>
<li>如果对象中存储的有其他的对象,在拷贝后的对象中也创建一个新的和里面对象除了内存地址不同,其他完全相同的对象</li>
<li>改变新对象中的任何内容,都不会对我们进行拷贝的对象造成任何影响</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xfj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;alex&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br></pre></td></tr></table></figure>

<h2 id="24-说出-Proxy-和-Object-defineProperty-的区别"><a href="#24-说出-Proxy-和-Object-defineProperty-的区别" class="headerlink" title="24. 说出 Proxy 和 Object.defineProperty 的区别"></a>24. 说出 Proxy 和 Object.defineProperty 的区别</h2><ul>
<li><p>Proxy 的设计初衷就是监听对象的改变,并且提供了 13 中方法监听对象的操作,大大方便了和丰富了对对象的监听操作</p>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>可以直接监听数组的变化</li>
</ul>
</li>
<li><p>Object.defineProperty</p>
<ul>
<li><p>该属性设计初衷是定义对象的属性,所以有些监听操作是监听不到的</p>
</li>
<li><p>对于复杂的对象,层级很深的话,需要深度监听</p>
</li>
<li><p>删除属性,添加属性是不能被监听的</p>
</li>
<li><p>不能监听数组的变化</p>
<ul>
<li>本质上是数组的 length 属性的数据属性描述符:</li>
<li>configurable: false 意味着 length 属性不能被修改,不能将 length 属性修改为存取属性描述符</li>
<li>所以数组长度的变化的不能被监听的</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="params"><span class="built_in">Object</span>.getOwnPropertyDescriptors(num)</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: &#123; <span class="attr">value</span>: <span class="number">3</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">length</span>: &#123; <span class="attr">value</span>: <span class="number">3</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-说说-Reflect-的作用和为什么需要使用它"><a href="#25-说说-Reflect-的作用和为什么需要使用它" class="headerlink" title="25. 说说 Reflect 的作用和为什么需要使用它"></a>25. 说说 Reflect 的作用和为什么需要使用它</h2><ul>
<li>Reflect<ul>
<li>是一个对象</li>
<li>提供了多种方法方便我们统一管理对象,在对对象进行操作时有些方法会有返回值,操作对象变的更加规范</li>
<li>Object 作为构造函数,操作对象的方法放在它身上不是很合适,早期的设计不规范导致的</li>
<li>在使用 Proxy 监听对象时,使用 Reflect 避免了对原对象的直接操作</li>
</ul>
</li>
</ul>
<h2 id="26-说说-Promise-的作用和使用方法（各个回调的作用）"><a href="#26-说说-Promise-的作用和使用方法（各个回调的作用）" class="headerlink" title="26. 说说 Promise 的作用和使用方法（各个回调的作用）"></a>26. 说说 Promise 的作用和使用方法（各个回调的作用）</h2><ul>
<li>Promise<ul>
<li>异步编程的一种解决方案,比传统的解决方案–回调函数-更加合理和更强大</li>
<li>是一个对象</li>
<li>对象的状态不受外界影响</li>
<li>一旦状态改变,就不会再变</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(value); <span class="comment">//该函数执行时会回调onFulfilled</span></span><br><span class="line">  <span class="title function_">reject</span>(reason); <span class="comment">//该函数执行时会回调onRejected</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这个回调函数会被立即执行~&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听promise对象的状态 方式一</span></span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled).<span class="title function_">catch</span>(onRejected);</span><br><span class="line"><span class="comment">// 监听promise对象的状态 方式二</span></span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>

<h2 id="27-说一下你知道的-Promise-的实例方法和类方法"><a href="#27-说一下你知道的-Promise-的实例方法和类方法" class="headerlink" title="27. 说一下你知道的 Promise 的实例方法和类方法"></a>27. 说一下你知道的 Promise 的实例方法和类方法</h2><ul>
<li>Promise 的实例方法:<ul>
<li>then(onFulfilled,onRejected)<ul>
<li>onFulfilled —-&gt;成功时的回调</li>
<li>onRejected —-&gt; 失败时的回调</li>
<li>返回值是一个新的 promise 对象 所以 promise 支持链式调用的原因</li>
</ul>
</li>
<li>catch(onRejected)<ul>
<li>onRejected —-&gt;失败时的回调</li>
</ul>
</li>
<li>finally(callback)<ul>
<li>callback —-&gt;不管 promise 最后的状态,在执行完 then 或 catch 指定的回调函数后,都会执行的回调</li>
</ul>
</li>
</ul>
</li>
<li>Promise 的类方法<ul>
<li>all()<ul>
<li>接受一个数组作为参数,数组元素是 promise 对象,返回一个新的 promise 对象</li>
<li>可以不是数组,但必须是可迭代对象,且返回的每一个成员都是 Promise 实例</li>
<li>只有数组里所以的 promise 对象都是 fulfilled 状态时,返回的 promsie 的状态是 fulfilled</li>
<li>当数组中的 promise 对象有一个的 rejected 状态时,返回的 promise 的状态时 rejected</li>
</ul>
</li>
<li>race()<ul>
<li>接受一个数组作为参数,数组元素是 promise 对象,返回一个新的 promise 对象</li>
<li>只要数组中的实例有一个率先改变,返回的 promise 对象就跟着改变</li>
</ul>
</li>
<li>allSettled()<ul>
<li>接受一个数组作为参数,数组元素是 promise 对象,返回一个新的 promise 对象</li>
<li>只有等数组中所有的 promise 对象都发生状态改变后,返回的 promsie 对象状态才会改变</li>
<li>返回的 promsie 对象,一旦状态发生改变,状态总是 fulfilled</li>
</ul>
</li>
<li>any()<ul>
<li>接受一个数组作为参数,数组元素是 promise 对象,返回一个新的 promise 对象</li>
<li>只要数组实例中有一个变成 fulfilled 状态,返回的 promise 对象就会变成 fulfilled 状态</li>
<li>只有当数组中所有的 promise 实例都变成 rejected 状态,返回的 promise 对象才变成 rejected 状态</li>
</ul>
</li>
<li>resolve()<ul>
<li>将现有对象转为 promsie 实例</li>
</ul>
</li>
<li>rejected()<ul>
<li>返回一个新的 promsie 实例,该实例的状态为 rejected</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="28-什么是迭代器？什么是可迭代对象？"><a href="#28-什么是迭代器？什么是可迭代对象？" class="headerlink" title="28. 什么是迭代器？什么是可迭代对象？"></a>28. 什么是迭代器？什么是可迭代对象？</h2><ul>
<li><p><strong>迭代器</strong></p>
<ul>
<li><p>迭代器是帮助我们对某个数据结构进行遍历的对象</p>
</li>
<li><p>迭代器也是一个具体的对象，这个对象需要符合迭代器<strong>协议</strong></p>
<ul>
<li>迭代器协议定义了产生一系列值（无论是有限还是无限个）的标准方式</li>
<li>在<code>JavaScript</code>中这个标准就是一个特定的<code>next</code>方法</li>
</ul>
</li>
<li><p><code>next</code>方法的要求</p>
<ul>
<li>一个无参数或者一个参数的函数，返回一个应当拥有以下两个属性的对象：</li>
<li><code>done</code>（<code>boolean</code>）<ul>
<li>如果迭代器可以产生序列中的下一个值，则为 <code>false</code>。（这等价于没有指定 <code>done </code>这个属性。）</li>
<li>如果迭代器已将序列迭代完毕，则为 <code>true</code>。这种情况下，<code>value </code>是可选的，如果它依然存在，即为迭代结束之后的默认返回值。</li>
</ul>
</li>
<li><code>value</code><ul>
<li>迭代器返回的任何 <code>JavaScript </code>值。<code>done </code>为 <code>true </code>时可省略</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装一个为数组创建迭代器的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createArrayIterator</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: arr[index++] &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>可迭代对象</strong></p>
<ul>
<li><p>和迭代器不是一个概念</p>
</li>
<li><p>当一个对象实现了<code>iterable protocol</code>协议时，它就是一个可迭代对象；</p>
</li>
<li><p>这个对象的要求是必须实现 <code>Symbol.iterator（@@iterator）</code>方法，在代码中我们使用 <code>Symbol.iterator </code>访问该属性</p>
</li>
<li><p>转成这样的好处</p>
<ul>
<li>当一个对象变成一个可迭代对象的时候，就可以进行某些迭代操作</li>
<li>比如 <code>for...of</code> 操作时，其实就会调用它的<code> Symbol.iterator</code> 方法</li>
</ul>
</li>
<li><p>实现可迭代协议的原生对象</p>
<ul>
<li><code>String</code>、<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>arguments</code>对象、<code>NodeList</code>集合…</li>
</ul>
</li>
<li><p>可迭代对象的应用</p>
<ul>
<li>JavaScript 中语法：<code>for ...of</code>、展开语法（<code>spread syntax</code>）、<code>yield*</code>、解构赋值（<code>Destructuring_assignment</code>）</li>
<li>创建一些对象时：<code>new Map([Iterable])、new WeakMap([iterable])、new Set([iterable])、new WeakSet([iterable])</code></li>
<li>一些方法的调用：<code>Promise.all(iterable)、Promise.race(iterable)、Array.from(iterable)</code></li>
</ul>
</li>
<li><p>迭代器的中断</p>
<ul>
<li>比如遍历的过程中通过<code>break、return、throw</code>中断了循环操作</li>
<li>比如在解构的时候，没有解构所有的值</li>
</ul>
</li>
<li><p>自定义类的迭代实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">name, age, height, friends</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 实例方法</span></span><br><span class="line">      <span class="title function_">running</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">/      [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> iterator = &#123;</span><br><span class="line">          <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="variable language_">this</span>.<span class="property">friends</span>.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">friends</span>[index++] &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iterator</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="29-什么是生成器？生成器和迭代器有什么关系？"><a href="#29-什么是生成器？生成器和迭代器有什么关系？" class="headerlink" title="29. 什么是生成器？生成器和迭代器有什么关系？"></a>29. 什么是生成器？生成器和迭代器有什么关系？</h2><ul>
<li><p><strong>生成器 (ES6 新增)</strong></p>
<ul>
<li><p>生成器函数也是一个函数，但是和普通的函数有一些区别</p>
<ul>
<li>首先，生成器函数需要在 function 的后面加一个符号：<code>*</code></li>
<li>其次，生成器函数可以通过 yield 关键字来控制函数的执行流程：</li>
<li>最后，生成器函数的返回值是一个（生成器）<ul>
<li>生成器事实上是一种特殊的迭代器</li>
</ul>
</li>
</ul>
</li>
<li><p>生成器函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">生成器函数:</span><br><span class="line"><span class="number">1.</span><span class="keyword">function</span>后面会跟上符号: *</span><br><span class="line"><span class="number">2.</span>代码的执行可以被<span class="keyword">yield</span>控制</span><br><span class="line"><span class="number">3.</span>生成器函数默认在执行时, 返回一个生成器对象</span><br><span class="line">    * 要想执行函数内部的代码, 需要生成器对象, 调用它的next操作</span><br><span class="line">    * 当遇到<span class="keyword">yield</span>时, 就会中断执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成器传递参数 – next 函数</p>
<ul>
<li>调用 next 函数的时候，可以给它传递参数，那么这个参数会作为上一个 yield 语句的返回值</li>
<li>也就是说我们是为本次的函数代码块执行提供了一个值</li>
</ul>
</li>
<li><p>生成器提前结束</p>
<ul>
<li>return 传值后这个生成器函数就会结束，之后调用 next 不会继续生成值</li>
</ul>
</li>
<li><p>生成器替代迭代器</p>
<ul>
<li>使用 yield 来生产一个可迭代对象</li>
<li>这个时候相当于是一种 yield 的语法糖，只不过会依次迭代这个可迭代对象，每次迭代其中的一个值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">createArrayIterator</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义类迭代 – 生成器实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以Person为例  添加到实例方法</span></span><br><span class="line">*[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="variable language_">this</span>.<span class="property">friends</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="30-异步函数和普通函数的区别"><a href="#30-异步函数和普通函数的区别" class="headerlink" title="30. 异步函数和普通函数的区别"></a>30. 异步函数和普通函数的区别</h2><ul>
<li><p><strong>异步函数</strong></p>
<ul>
<li><p>使用<code>async</code>关键字声明的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async function foo() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const bar = async function() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const baz = async () =&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Person &#123;</span></span><br><span class="line"><span class="comment">//   async running() &#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>异步函数的执行流程</p>
<ul>
<li>异步函数的内部代码执行过程和普通的函数是一致的，默认情况下也是会被同步执行</li>
<li>返回值和普通函数的区别<ul>
<li>情况一：异步函数也可以有返回值，但是异步函数的返回值相当于被包裹到<code>Promise.resolve</code>中</li>
<li>情况二：如果我们的异步函数的返回值是<code>Promise</code>，状态由会由<code>Promise</code>决定；</li>
<li>情况三：如果我们的异步函数的返回值是一个对象并且实现了<code>thenable</code>，那么会由对象的方<code>then</code>法来决定</li>
</ul>
</li>
<li>如果在<code>async</code>函数中抛出异常<ul>
<li>并不会报错, 而是作为<code>Promise</code>的<code>reject</code>来传递</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="31-说说线程和进程的区别以及关系"><a href="#31-说说线程和进程的区别以及关系" class="headerlink" title="31. 说说线程和进程的区别以及关系"></a>31. 说说线程和进程的区别以及关系</h2><ul>
<li><p><strong>进程</strong></p>
<ul>
<li>是<code>cpu</code>分配资源的最小单位；（是能拥有资源和独立运行的最小单位）</li>
<li>计算机已经运行的程序，是操作系统管理程序的一种方式 (<strong>官方说法</strong>)</li>
<li>可以认为启动一个应用程序，就会默认启动一个进程（也可能是多个进程）**(个人解释)**</li>
<li>也可以说进程是线程的容器</li>
</ul>
</li>
<li><p><strong>线程</strong></p>
<ul>
<li>是<code>cpu</code>调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>
<li>操作系统能够运行运算调度的最小单位，通常情况下它被包含在进程中 <strong>(官方说法)</strong></li>
<li>每一个进程中，都会启动至少一个线程用来执行程序中的代码，这个线程被称之为主线程</li>
</ul>
</li>
<li><p><strong>操作系统的工作方式</strong></p>
<ul>
<li>如何做到同时让多个进程同时工作?<ul>
<li>因为<code>CPU</code>的运算速度非常快, 可以快速的在多个进程之间迅速的切换</li>
<li>当进程中的线程获取到世间片时, 就可以快速执行我们编写的代码</li>
<li>由于<code>CPU</code>执行速度过于变态, 对于用户来说是感受不到这种快速切换的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>浏览器中<code>JavaScript</code>线程</strong></p>
<ul>
<li><p><strong><code>JavaScript</code>为什么是单线程的</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom;这决定了它只能是单线程，否则会带来很复杂的同步问题。举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进程容器是浏览器或者<code>Node</code></li>
</ul>
</li>
<li><p><strong>浏览器是多进程的?</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  放在浏览器中，每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。所以，浏览器是一个多进程的。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM.所以，这个新标准并没有改变JavaScript单线程的本质。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目前多数浏览器都是多进程的, 打开一个<code>tab</code>页面就会开启一个新的进程, 防止因为一个页面的卡死导致浏览器的强制退出</li>
<li>每个进程中又有很多的线程，其中包括执行<code>JavaScript</code>代码的线程</li>
</ul>
</li>
<li><p>线程中<code>JavaScript</code>代码的执行</p>
<ul>
<li>它是在一个单独的线程中执行的, 意味着<code>JavaScript</code>代码在同一时刻只能做一件事</li>
<li>这<strong>非常耗时</strong>, 意味着当前线程会被阻塞</li>
</ul>
</li>
<li><p>所以耗时的操作并不是在<code>JavaScript</code>线程中执行的</p>
<ul>
<li>浏览器的每个进程是多线程的，那么其他线程可以来完成这个耗时的操作</li>
<li>比如网络请求、定时器，只需要在特性的时候执行应该有的回调即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="32-说说你对事件队列、微任务、宏任务的理解"><a href="#32-说说你对事件队列、微任务、宏任务的理解" class="headerlink" title="32. 说说你对事件队列、微任务、宏任务的理解"></a>32. 说说你对事件队列、微任务、宏任务的理解</h2><ul>
<li><strong>事件队列</strong><ul>
<li>事件队列是一种数据结构，可以存放要执行的任务。它符合<strong>队列</strong>“<strong>先进先出</strong>”的特点</li>
</ul>
</li>
<li><strong>宏&#x2F;微任务</strong><ul>
<li>首先它们都是异步任务</li>
<li>宏任务列队<ul>
<li>用来保存待执行的宏任务（回调）</li>
<li>如: <code>ajax、setTimeout、setInterval、DOM</code>监听、<code>UI Rendering</code>等 会被加入到宏列队</li>
</ul>
</li>
<li>微任务列队<ul>
<li>用来保存待执行的微任务（回调）</li>
<li>如: <code>Promise</code>的<code>then</code>回调、 <code>Mutation Observer API、queueMicrotask()</code>等 会被加入到微列队</li>
</ul>
</li>
<li><code>JS</code>执行时会区别这两个队列<ul>
<li><code>JS</code>引擎首先必须先执行所有的初始化同步任务代码</li>
<li>每次准备取出第一个宏任务执行前，都要将所有的微任务一个一个取出来执行，</li>
<li>也就是优先级比宏任务高，且与微任务所处的代码位置无关</li>
<li>也就是宏任务执行之前，必须保证微任务队列是空的；</li>
<li>如果不为空，那么就优先执行微任务队列中的任务（回调）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="33-LocalStorage-和-SessionStorage-的区别"><a href="#33-LocalStorage-和-SessionStorage-的区别" class="headerlink" title="33. LocalStorage 和 SessionStorage 的区别"></a>33. LocalStorage 和 SessionStorage 的区别</h2><ul>
<li>LocalStorage 提供一种永久性存储的方法 在网页关闭打开时 依然保留</li>
<li>SessionStorage: 会话存储 再关闭该网页时 存储的内容被清除</li>
<li>区别:<ul>
<li>localStorage 永久性存储 SessionStorage 在关闭当前页面时存储的内容就会失效</li>
<li>SessionStorage 只能被同一个窗口的同源页面共享 localStorage 除非手动删除 否则一直存在</li>
</ul>
</li>
</ul>
<h2 id="34-说说你对防抖、节流的理解，他们的区别，应用场景"><a href="#34-说说你对防抖、节流的理解，他们的区别，应用场景" class="headerlink" title="34. 说说你对防抖、节流的理解，他们的区别，应用场景"></a>34. 说说你对防抖、节流的理解，他们的区别，应用场景</h2><p>防抖: 将多次执行函数变成最后一次执行 等待固定时间还没有事件触发时执行的函数</p>
<ul>
<li><p>应用场景</p>
<ul>
<li>按钮的点击</li>
<li>屏幕滚动时的复杂计算</li>
<li>输入框输入时进行搜索</li>
<li>用户缩放浏览器的 resize 事件</li>
</ul>
</li>
<li><p>简单的防抖函数实现</p>
</li>
<li><pre><code class="js">function myDebounce(execFn, delay) &#123;
  let timer = 0;

  function _debounce(...args) &#123;
    if (timer) clearTimeout(timer);
    timer = setTimeout(() =&gt; &#123;
      execFn.apply(this, args);
      timer = null;
    &#125;, delay);
  &#125;

  return _debounce;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">节流: 按照固定的时间频率(间隔)来执行对应的函数</span><br><span class="line"></span><br><span class="line">- 应用场景:</span><br><span class="line"></span><br><span class="line">  - 监听页面的滚动事件 通过节流来降低事件调用的频率</span><br><span class="line">  - 鼠标移动</span><br><span class="line">  - 用户频繁点击按钮的操作</span><br><span class="line"></span><br><span class="line">- 简单实现</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  function myThrottle(execFn, interval) &#123;</span><br><span class="line">    let initTime = 0;</span><br><span class="line">  </span><br><span class="line">    function throttle(...args) &#123;</span><br><span class="line">      let nowTime = Date.now();</span><br><span class="line">      const waitTime = interval - (nowTime - initTime);</span><br><span class="line">      if (waitTime &lt;= 0) &#123;</span><br><span class="line">        execFn.apply(this, args);</span><br><span class="line">        initTime = nowTime;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return throttle;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="35-说说对象的引用赋值、浅拷贝、深拷贝的区别"><a href="#35-说说对象的引用赋值、浅拷贝、深拷贝的区别" class="headerlink" title="35. 说说对象的引用赋值、浅拷贝、深拷贝的区别"></a>35. 说说对象的引用赋值、浅拷贝、深拷贝的区别</h2><p>对象的引用赋值</p>
<ul>
<li>把源对象指向自身所在堆内存空间的指针给了新对象 两个对象所指向的内存空间是一样的 修改其中一个的值 另一个也会发生改变</li>
</ul>
<p>对象的浅拷贝</p>
<ul>
<li>可以通过{…obj}的方式进行对象的浅拷贝 (Object.assign({},obj))</li>
<li>对于 obj 中的值是原始数据类型的 将对应的值赋值给了 newObj 中对应的属性</li>
<li>对于 obj 中是复杂数据类型的值 把对应在内存中的指针赋值给了 newObj 中对应的 key 对于复杂数据类型的 value 修改其中一个另一个也发生改变</li>
</ul>
<p>对象的深拷贝(真实开发中使用非常少)</p>
<ul>
<li><p>newObj 与 obj 中的属性值一样 但是是一个全新的对象 与元对象没有任何关系</p>
</li>
<li><p>默认情况下 js 没有提供对应的深拷贝的方式 因为深拷贝是非常消耗内存的</p>
</li>
<li><p>有对应的库实现了深拷贝</p>
</li>
<li><p>实现深拷贝</p>
<ul>
<li><p>JSON.parse(JSON.stringfy(obj))</p>
<ul>
<li>缺点: 对于某些属性如 undefined,Symbol,function,Symbol 会自动忽略; 对于 set map 会转成对象</li>
</ul>
</li>
<li><p>自己实现</p>
<ul>
<li><pre><code class="js">//判断一个变量是不是对象类型的
function isObject(obj) &#123;
  const objType = typeof obj;
  return obj !== null &amp;&amp; objType === &#39;object&#39;;
&#125;

//自己编写一个深拷贝函数
function deepClone(data) &#123;
  //不是对象类型
  if (!isObject(data)) return data;
  //对象类型
  const newObj = Array.isArray(data) ? [] : &#123;&#125;;
  for (const k in data) &#123;
    newObj[k] = deepClone(data[k]);
  &#125;
  return newObj;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 36. 事件总线的基本实现和使用</span><br><span class="line"></span><br><span class="line">利用对象存储所有的事件，然后通过 set 保证事件的唯一</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">class myEventBus &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.eventBus = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(eventName, eventFn) &#123;</span><br><span class="line">    let eventSet = this.eventBus[eventName];</span><br><span class="line">    if (!eventSet) &#123;</span><br><span class="line">      eventSet = new Set();</span><br><span class="line">      this.eventBus[eventName] = eventSet;</span><br><span class="line">    &#125;</span><br><span class="line">    this.eventBus[eventName].add(eventFn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off(eventName, eventFn) &#123;</span><br><span class="line">    if (!this.eventBus[eventName]) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    const eventSet = this.eventBus[eventName];</span><br><span class="line">    if (eventSet.has(eventFn)) this.eventBus[eventName].delete(eventFn);</span><br><span class="line">    if (!this.eventBus[eventName].size) &#123;</span><br><span class="line">      delete this.eventBus[eventName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(eventName, ...payload) &#123;</span><br><span class="line">    if (!this.eventBus[eventName]) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (const item of this.eventBus[eventName]) &#123;</span><br><span class="line">      item(...payload);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mitt = new myEventBus();</span><br><span class="line">mitt.on(&#x27;alex&#x27;, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;123&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">const fn = () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;456&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">mitt.on(&#x27;alex&#x27;, fn);</span><br><span class="line">mitt.on(&#x27;alex&#x27;, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;789&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  mitt.off(&#x27;alex&#x27;, fn);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  mitt.emit(&#x27;alex&#x27;);</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="37-说说服务端渲染和前后端分离的区别"><a href="#37-说说服务端渲染和前后端分离的区别" class="headerlink" title="37. 说说服务端渲染和前后端分离的区别"></a>37. 说说服务端渲染和前后端分离的区别</h2><p>SSR(server side rendering) 服务端渲染</p>
<ul>
<li>优点:<ul>
<li>更快的响应时间 不用等待所有的 js 加载完成 也能显示比较完整的页面</li>
<li>更好的 SEO 可以将 SEO 的关键信息直接在后台渲染成 html 保证了搜索引擎能爬取到关键数据</li>
<li>无需占用客户端资源 解析模板交给后端工作 对于客户端的资源占用更少</li>
</ul>
</li>
<li><h2 id="缺点-占用服务器资源-一个小小的页面的改动-都需要请求一次完整的-html-页面-有悖于程序员的-x3D-x3D-”DRY-Don-96-t-repeat-yourself-”-x3D-x3D-原则-如果短时间访问过多-对服务器造成一定的访问压力"><a href="#缺点-占用服务器资源-一个小小的页面的改动-都需要请求一次完整的-html-页面-有悖于程序员的-x3D-x3D-”DRY-Don-96-t-repeat-yourself-”-x3D-x3D-原则-如果短时间访问过多-对服务器造成一定的访问压力" class="headerlink" title="缺点- 占用服务器资源 一个小小的页面的改动 都需要请求一次完整的 html 页面 有悖于程序员的&#x3D;&#x3D;”DRY(Don&#96;t repeat yourself)”&#x3D;&#x3D;原则 如果短时间访问过多 对服务器造成一定的访问压力"></a>缺点<br>- 占用服务器资源 一个小小的页面的改动 都需要请求一次完整的 html 页面 有悖于程序员的&#x3D;&#x3D;”DRY(Don&#96;t repeat yourself)”&#x3D;&#x3D;原则 如果短时间访问过多 对服务器造成一定的访问压力</h2><ul>
<li>一些常见的 api 需要先对运行环境判断再使用</li>
</ul>
</li>
</ul>
<p>前后端分离</p>
<ul>
<li>优点:<ul>
<li>前端专注于 ui 界面的开发 后端专注于 api 的开发 单一</li>
<li>体验更好</li>
</ul>
</li>
<li>缺点:<ul>
<li>第一次响应内容较慢 不如服务端渲染快</li>
<li>不利于 SEO 优化 只是记录一个页面 对于 SEO 较差</li>
</ul>
</li>
</ul>
<h2 id="38-说说你对-HTTP-协议的理解"><a href="#38-说说你对-HTTP-协议的理解" class="headerlink" title="38. 说说你对 HTTP 协议的理解"></a>38. 说说你对 HTTP 协议的理解</h2><p>http</p>
<ul>
<li>HyperText Transfer Protocol 超文本传输协议</li>
<li>超文本传输协议是一种用于分布式协作式的应用层协议</li>
<li>定义了客户端和服务器之间交换报文的格式和方式 默认为 80 端口</li>
<li>使用 tcp 作为传输层协议 保证了数据的可靠性</li>
</ul>
<p>组成:<code>一个HTTP请求主要包括: 请求和响应</code></p>
<ul>
<li><p>请求</p>
<ul>
<li><p>主要包含: 请求行 请求头 请求体</p>
</li>
<li><p>请求行:</p>
<ul>
<li><p>请求方法字段</p>
</li>
<li><p>URL 字段</p>
</li>
<li><p>HTTP 协议版本字段</p>
</li>
<li><pre><code class="js">GET/index.html HTTP/1.1
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 请求头:</span><br><span class="line"></span><br><span class="line">    - 键值对组成</span><br><span class="line">    - User-Agent: 对应展示的浏览器的类型</span><br><span class="line">    - Content-type: 对应的请求内容的数据类型</span><br><span class="line">      - application/x-www-form-urlencoded 数据以&amp;分割 的键值对 键值对用=分割</span><br><span class="line">      - application/json json 类型</span><br><span class="line">      - application/xml xml 类型</span><br><span class="line">      - text/plain 文本类型</span><br><span class="line">      - multipart/form-data 表示上传文件</span><br><span class="line">    - keep-alive</span><br><span class="line"></span><br><span class="line">  - 请求体: get/post 所带的内容</span><br><span class="line"></span><br><span class="line">- 响应</span><br><span class="line"></span><br><span class="line">  - 响应行</span><br><span class="line"></span><br><span class="line">    - 由协议版本 状态码 状态码的原因短语组成</span><br><span class="line"></span><br><span class="line">    - ```js</span><br><span class="line">      HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>响应头</p>
</li>
<li><p>响应体</p>
</li>
</ul>
</li>
</ul>
<p>请求方法</p>
<ul>
<li>get 向服务器获取数据</li>
<li>post 将响应实体交给指定的资源</li>
<li>head 请求一个与 get 请求响应相同的响应 没有实体</li>
<li>put 上传文件 用于替换目标资源的所有</li>
<li>patch 用于对资源的部分修改</li>
<li>delete 删除指定的资源</li>
<li>connect: 建立一个到目标资源标识的服务器的隧道 通常用于代理服务器</li>
<li>track: 回显服务器收到的请求 主要用于测试和诊断</li>
</ul>
<p>响应状态码</p>
<ul>
<li>200 表示请求被服务器端正常处理</li>
<li>201 post 请求 创建新的资源</li>
<li>301 永久重定向 表示资源被分配了新的 URI 并返回该 URI</li>
<li>4xx 表示客户端发生错误<ul>
<li>400 请求报文存在语法错误</li>
<li>401 未授权的错误 必须携带身份信息</li>
<li>403 没有权限访问</li>
<li>404 服务器找不到请求资源</li>
</ul>
</li>
<li>5xx 服务器错误<ul>
<li>500</li>
<li>503 服务器不可用 处于维护或重载状态</li>
</ul>
</li>
</ul>
<h2 id="39-封装-XMLHttpRequest-网络请求"><a href="#39-封装-XMLHttpRequest-网络请求" class="headerlink" title="39. 封装 XMLHttpRequest 网络请求"></a>39. 封装 XMLHttpRequest 网络请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理urlencoded字符串格式问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queryStringify</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) str += <span class="string">`<span class="subst">$&#123;k&#125;</span>=<span class="subst">$&#123;obj[k]&#125;</span>&amp;`</span>;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装 ajax</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="comment">//默认配置</span></span><br><span class="line">  <span class="keyword">let</span> defaultoptions = &#123;</span><br><span class="line">    <span class="comment">//地址</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">//请求方式</span></span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="comment">//是否异步</span></span><br><span class="line">    <span class="attr">async</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//请求携带的信息</span></span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">//请求头</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">//请求成功的回调</span></span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="comment">//请求失败的回调</span></span><br><span class="line">    <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//从你传进来的options配置对象中，解构赋值</span></span><br><span class="line">  <span class="keyword">let</span> &#123; url, method, <span class="keyword">async</span>, data, headers, success, error &#125; = &#123;</span><br><span class="line">    ...defaultoptions,</span><br><span class="line">    ...options,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">    <span class="comment">//?.先判断？前的变量是否存在，存在则执行后续操作，不存在则不执行</span></span><br><span class="line">    <span class="comment">//请求头是否设置了Content-type 如果设置了再判断是否有json</span></span><br><span class="line">    headers[<span class="string">&#x27;Content-type&#x27;</span>]?.<span class="title function_">indexOf</span>(<span class="string">&#x27;json&#x27;</span>) &gt; -<span class="number">1</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">//如果请求的信息为对象且请求头设置了链接类型 表明是post请求而且是json字符串的数据发送</span></span><br><span class="line">    data = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//否则用urlencoded 查询字符串格式</span></span><br><span class="line">    data = <span class="title function_">queryStringify</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是 get 请求, 并且有参数, 那么直接组装一下 url 信息</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/^get$/i</span>.<span class="title function_">test</span>(method) &amp;&amp; data) url += <span class="string">&#x27;?&#x27;</span> + data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 发送请求</span></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(method, url, <span class="keyword">async</span>);</span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/^2\d&#123;2&#125;$/</span>.<span class="title function_">test</span>(xhr.<span class="property">status</span>)) &#123;</span><br><span class="line">      <span class="title function_">error</span>(<span class="string">`错误状态码:<span class="subst">$&#123;xhr.status&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行解析</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">      <span class="title function_">success</span>(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">error</span>(<span class="string">&#x27;解析失败 ! 因为后端返回的结果不是 json 格式字符串&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置请求头内的信息</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> headers) xhr.<span class="title function_">setRequestHeader</span>(k, headers[k]);</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/^get$/i</span>.<span class="title function_">test</span>(method)) &#123;</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    xhr.<span class="title function_">send</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Pajax</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="comment">// const p = new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   ajax(&#123;</span></span><br><span class="line">  <span class="comment">//     ...options,</span></span><br><span class="line">  <span class="comment">//     success: function (res) &#123;</span></span><br><span class="line">  <span class="comment">//       resolve(res);</span></span><br><span class="line">  <span class="comment">//     &#125;,</span></span><br><span class="line">  <span class="comment">//     error: function (err) &#123;</span></span><br><span class="line">  <span class="comment">//       reject(err);</span></span><br><span class="line">  <span class="comment">//     &#125;,</span></span><br><span class="line">  <span class="comment">//   &#125;);</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  <span class="comment">// return p;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">ajax</span>(&#123;</span><br><span class="line">      ...options,</span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">Pajax</span> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="40-说说-XMLHttpRequest-和-Fetch-请求的异同"><a href="#40-说说-XMLHttpRequest-和-Fetch-请求的异同" class="headerlink" title="40. 说说 XMLHttpRequest 和 Fetch 请求的异同"></a>40. 说说 XMLHttpRequest 和 Fetch 请求的异同</h2><p>Fecth 提供了一种更加现代的处理方案</p>
<ul>
<li>比如返回一个值是<code>Promise</code><ul>
<li>在请求成功时调用 resolve 回调</li>
</ul>
</li>
<li>与 XMLHttpRequest 不同 不用把所有操作放在同一个对象上</li>
<li>语法简单 更加语义化</li>
<li>基于标准的 promise 实现 支持 async&#x2F;await</li>
<li>更加底层</li>
</ul>
<p>Fetch 缺点</p>
<ul>
<li>不支持 abort(超时取消请求) 不支持超时控制</li>
<li>没有办法检测请求进度 XHR 可以</li>
<li>默认不会携带 cookie</li>
</ul>
<p>ajax 缺点</p>
<ul>
<li>使用起来比较繁琐</li>
</ul>
<h2 id="41-从哪些点进行性能优化"><a href="#41-从哪些点进行性能优化" class="headerlink" title="41.从哪些点进行性能优化?"></a>41.从哪些点进行性能优化?</h2><p>加载:</p>
<ol>
<li>减少http请求(精灵图)</li>
<li>减少文件大小(资源压缩,图片压缩,代码压缩)</li>
<li>CDN(第三方库,大文件,大图)</li>
<li>预加载,ssr服务端渲染</li>
<li>懒加载</li>
<li>分包(按需加载)</li>
</ol>
<p>性能:</p>
<p>1.减少dom操作,避免回流,文档碎片</p>
<p>性能分析:</p>
<ol>
<li>页面加载性能</li>
<li>动画与操作性能</li>
<li>内存占用</li>
<li>电量消耗</li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>RickyD
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://muleandhorse.icu/2022/05/21/js%E9%AB%98%E9%98%B6%E5%85%AB%E8%82%A1%E6%96%87/" title="JS高阶的一些八股文">http://muleandhorse.icu/2022/05/21/js高阶八股文/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag"># 前端开发</a>
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
              <a href="/tags/javascript/" rel="tag"># javascript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/19/b31%20%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%20/" rel="prev" title="javascript 笔记25-迭代器与生成器">
      <i class="fa fa-chevron-left"></i> javascript 笔记25-迭代器与生成器
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/21/webpack%E5%85%AB%E8%82%A1%E6%96%87/" rel="next" title="JS高阶的一些八股文">
      JS高阶的一些八股文 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81ODIzMi8zNDY5NQ=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-this-%E7%9A%84%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99"><span class="nav-number">1.</span> <span class="nav-text">1. this 的绑定规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%AF%B4%E5%87%BA-apply%E3%80%81call%E3%80%81bind-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">2. 说出 apply、call、bind 函数的用法和区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%AF%B4%E5%87%BA%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%84%E7%A7%8D%E7%94%A8%E6%B3%95%E5%92%8C%E7%AE%80%E5%86%99"><span class="nav-number">3.</span> <span class="nav-text">3. 说出箭头函数的各种用法和简写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%AF%B4%E5%87%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">4. 说出浏览器输入一个 URL 到页面显示的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%AF%B4%E8%AF%B4-async-%E5%92%8C-defer-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">5. 说说 async 和 defer 的使用以及区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%86%99%E5%87%BA-v8-%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">6. 写出 v8 引擎执行代码的大致流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E8%AF%B4%E4%B8%80%E4%B8%8B-JavaScript-%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">7. 说一下 JavaScript 的代码的执行流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-GO-x2F-AO-x2F-VO-%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">8.</span> <span class="nav-text">8. 说说你对 GO&#x2F;AO&#x2F;VO 的理解以及作用域和作用域链的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E8%AF%B4%E8%AF%B4-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">9.</span> <span class="nav-text">9. 说说 V8 引擎的内存管理以及垃圾回收器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%E7%9A%84-%E9%97%AD%E5%8C%85%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">10.</span> <span class="nav-text">10. 你是如何理解闭包的,闭包到底是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E9%97%AD%E5%8C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">11.</span> <span class="nav-text">11. 闭包为什么会产生内存泄露以及如何解决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E7%90%86%E8%A7%A3%E7%BA%AF%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="nav-number">12.</span> <span class="nav-text">12. 理解纯函数以及编写自己的纯函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%AF%B4%E5%87%BA%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">13.</span> <span class="nav-text">13. 理解函数柯里化以及说出柯里化的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E7%90%86%E8%A7%A3%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">14.</span> <span class="nav-text">14. 理解组合函数以及组合函数的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">15.</span> <span class="nav-text">15. 说说你对严格模式的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">16. 什么是原型、原型链？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-ES5-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%90%84%E4%B8%AA%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">17.</span> <span class="nav-text">17. ES5 继承的各个方案以及优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E7%BC%96%E5%86%99-ES6-%E7%9A%84%E7%B1%BB%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="nav-number">18.</span> <span class="nav-text">18. 编写 ES6 的类并且实现继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">19.</span> <span class="nav-text">19. 说说你对面向对象多态的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E6%95%B4%E7%90%86-ES6-ES11-%E6%96%B0%E5%A2%9E%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">20.</span> <span class="nav-text">20. 整理 ES6~ES11 新增知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E8%AF%B4%E8%AF%B4-Symbol-%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="nav-number">21.</span> <span class="nav-text">21. 说说 Symbol 的用法和作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-Set%E3%80%81WeakSet%E3%80%81Map%E3%80%81WeakMap-%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">22.</span> <span class="nav-text">22. 说说你对 Set、WeakSet、Map、WeakMap 的了解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%BC%95%E7%94%A8%E8%B5%8B%E5%80%BC-%E6%B5%85%E6%8B%B7%E8%B4%9D-%E6%B7%B1%E6%8B%B7%E5%86%85%E5%AD%98%E6%83%85%E5%86%B5"><span class="nav-number">23.</span> <span class="nav-text">23. 说一下引用赋值-浅拷贝-深拷内存情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E8%AF%B4%E5%87%BA-Proxy-%E5%92%8C-Object-defineProperty-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">24.</span> <span class="nav-text">24. 说出 Proxy 和 Object.defineProperty 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E8%AF%B4%E8%AF%B4-Reflect-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AE%83"><span class="nav-number">25.</span> <span class="nav-text">25. 说说 Reflect 的作用和为什么需要使用它</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E8%AF%B4%E8%AF%B4-Promise-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E5%90%84%E4%B8%AA%E5%9B%9E%E8%B0%83%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%89"><span class="nav-number">26.</span> <span class="nav-text">26. 说说 Promise 的作用和使用方法（各个回调的作用）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84-Promise-%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">27.</span> <span class="nav-text">27. 说一下你知道的 Promise 的实例方法和类方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">28. 什么是迭代器？什么是可迭代对象？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">29. 什么是生成器？生成器和迭代器有什么关系？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">30.</span> <span class="nav-text">30. 异步函数和普通函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%85%B3%E7%B3%BB"><span class="nav-number">31.</span> <span class="nav-text">31. 说说线程和进程的区别以及关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">32.</span> <span class="nav-text">32. 说说你对事件队列、微任务、宏任务的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-LocalStorage-%E5%92%8C-SessionStorage-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">33.</span> <span class="nav-text">33. LocalStorage 和 SessionStorage 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">34.</span> <span class="nav-text">34. 说说你对防抖、节流的理解，他们的区别，应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-%E8%AF%B4%E8%AF%B4%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">35.</span> <span class="nav-text">35. 说说对象的引用赋值、浅拷贝、深拷贝的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E8%AF%B4%E8%AF%B4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%92%8C%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">37. 说说服务端渲染和前后端分离的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-%E5%8D%A0%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90-%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%94%B9%E5%8A%A8-%E9%83%BD%E9%9C%80%E8%A6%81%E8%AF%B7%E6%B1%82%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84-html-%E9%A1%B5%E9%9D%A2-%E6%9C%89%E6%82%96%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84-x3D-x3D-%E2%80%9DDRY-Don-96-t-repeat-yourself-%E2%80%9D-x3D-x3D-%E5%8E%9F%E5%88%99-%E5%A6%82%E6%9E%9C%E7%9F%AD%E6%97%B6%E9%97%B4%E8%AE%BF%E9%97%AE%E8%BF%87%E5%A4%9A-%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%A0%E6%88%90%E4%B8%80%E5%AE%9A%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8E%8B%E5%8A%9B"><span class="nav-number">37.</span> <span class="nav-text">缺点- 占用服务器资源 一个小小的页面的改动 都需要请求一次完整的 html 页面 有悖于程序员的&#x3D;&#x3D;”DRY(Don&#96;t repeat yourself)”&#x3D;&#x3D;原则 如果短时间访问过多 对服务器造成一定的访问压力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-HTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">38.</span> <span class="nav-text">38. 说说你对 HTTP 协议的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-%E5%B0%81%E8%A3%85-XMLHttpRequest-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="nav-number">39.</span> <span class="nav-text">39. 封装 XMLHttpRequest 网络请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-%E8%AF%B4%E8%AF%B4-XMLHttpRequest-%E5%92%8C-Fetch-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">40.</span> <span class="nav-text">40. 说说 XMLHttpRequest 和 Fetch 请求的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-%E4%BB%8E%E5%93%AA%E4%BA%9B%E7%82%B9%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">41.</span> <span class="nav-text">41.从哪些点进行性能优化?</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="RickyD"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">RickyD</p>
  <div class="site-description" itemprop="description">如果站长加班加似了，这个网站就是他留给世界最后的遗产</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RickyDriver" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RickyDriver" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/1552330861@qq.com" title="E-Mail → 1552330861@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RickyD</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">135k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:30</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
